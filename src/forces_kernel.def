/*  Copyright 2011 Alexis Herault, Giuseppe Bilotta, Robert A. Dalrymple, Eugenio Rustico, Ciro Del Negro

	Istituto de Nazionale di Geofisica e Vulcanologia
          Sezione di Catania, Catania, Italy

    Universita di Catania, Catania, Italy

    Johns Hopkins University, Baltimore, MD

  Â  This file is part of GPUSPH.

    GPUSPH is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GPUSPH is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GPUSPH.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <vector_types.h>

#ifdef XSPH_KERNEL
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph,)
#	endif
#else
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,,)
#	endif
#endif

/************************************************************************************************************/
/*		   Kernels for computing forces with the different options											*/
/************************************************************************************************************/
template<KernelType kerneltype, BoundaryType boundarytype, bool periodicbound, bool usedem,
		 SPHFormulation sph_formulation>
__global__ void
__launch_bounds__(BLOCK_SIZE_FORCES, MIN_BLOCKS_FORCES)
FORCES_CUDA_KERNEL
(	
	float4*		posArray,
	float4*		forces,
	float2*		keps_dkde,
	float*		turbvisc,
	# ifdef XSPH_KERNEL
	float4*		xsph,
	# endif
	const uint*	neibsList,
	const uint	numParticles,
	const float deltap,
	const float	slength,
	const float	influenceradius,
	float4*		rbforces,
	float4*		rbtorques
	# ifdef DT_KERNEL
	,
	float*		cfl,
	float*		cflGamma,
	float*		cfltvisc
	# endif
)
{
	const uint index = INTMUL(blockIdx.x,blockDim.x) + threadIdx.x;   //particle number
	const uint lane = index/NEIBINDEX_INTERLEAVE;
	const uint offset = threadIdx.x & (NEIBINDEX_INTERLEAVE - 1);

	# ifdef DT_KERNEL
	__shared__ float sm_max[BLOCK_SIZE_FORCES];
	sm_max[threadIdx.x] = 0.0f;
	__shared__ float sm_max_g[BLOCK_SIZE_FORCES];
	sm_max_g[threadIdx.x] = 0.0f;
	# ifdef VISC_KEPS
	__shared__ float sm_max_nut[BLOCK_SIZE_FORCES];
	sm_max_nut[threadIdx.x] = 0.0f;
	# endif
	# endif

	if (index < numParticles) {
		// read particle info from texture
		const particleinfo info = tex1Dfetch(infoTex, index);

		// compute force only if the given particle is a fluid one
		if (FLUID(info)) {

			// read other particle data from textures or global mem
			#if( __COMPUTE__ >= 20)
			const float4 pos = posArray[index];
			#else
			const float4 pos = tex1Dfetch(posTex, index);
			#endif
			const float4 vel = tex1Dfetch(velTex, index);
			const float4 gradgamma = tex1Dfetch(gamTex, index);

			# ifdef VISC_SPS
			// read particle SPS matrix
			sym33mat tau;
			float2 temp = tex1Dfetch(tau0Tex, index);
			tau.a11 = temp.x;
			tau.a12 = temp.y;
			temp = tex1Dfetch(tau1Tex, index);
			tau.a13 = temp.x;
			tau.a22 = temp.y;
			temp = tex1Dfetch(tau2Tex, index);
			tau.a23 = temp.x;
			tau.a33 = temp.y;
			# endif

			# ifdef VISC_KEPS
			const float strain = tex1Dfetch(strainTex, index);
			const float keps_k = tex1Dfetch(keps_kTex, index);
			const float keps_e = tex1Dfetch(keps_eTex, index);
			const float turbVisc = 0.09f*keps_k*keps_k/keps_e;			// eddy viscosity
			float Pturb = turbVisc*strain*strain;						// production of turbulent kinetic energy (TKE)
			turbvisc[index] = turbVisc;

			float diff_term_k = 0;
			float diff_term_e = 0;
			const float dkdt_precalc = vel.w*(d_visccoeff + turbVisc);
			const float dedt_precalc = vel.w*(d_visccoeff + turbVisc/1.3f);
			// DEBUG OUTPUT
//			if(index == 100000) {
//				printf("Strain = %g\n", Strain);
//				printf("keps_k = %g\n", keps_k);
//				printf("keps_e = %g\n", keps_e);
//				printf("TurbVisc = %g\n", TurbVisc);
//				printf("Pturb = %g\n", Pturb);
//				printf("keps_dkde[index].x = %g\n", keps_dkde[index].x);
//				printf("keps_dkde[index].y = %g\n", keps_dkde[index].y);
//			}
			# endif

			// force and density derivative
			float4 force = make_float4(0.0f);

			# ifdef XSPH_KERNEL
			// XSPH correction
			float3 mean_vel = make_float3(0.0f);
			# endif

			/* Precomputed component of DvDt */
			float p_precalc = 0;
			switch (sph_formulation) {
				/* when using SPH formulation 1
				   we precompute p/rho^2 for the current particle */
				case SPH_F1:
					p_precalc = P(vel.w, PART_FLUID_NUM(info))/(vel.w*vel.w);                      //
					//in case of k-e model we use p~ = p + 2/3*rho*k
					# ifdef VISC_KEPS
					p_precalc += 2*keps_k/vel.w/3.f;
					# endif
					break;
				/* when using SPH formulation 2
				   we precompute the pressure for the current particle */
				case SPH_F2:
					p_precalc = P(vel.w, PART_FLUID_NUM(info));                                    //
					break;
			}

			//FIXME: Speed of sound should be calculated with MF_BOUNDARY, even when dt is constant
			//# if defined(DT_KERNEL) || defined(VISC_ARTVISC)
			/* sound speed sspeed is computed only once for the given particle */
			const float sspeed = soundSpeed(vel.w, PART_FLUID_NUM(info));
			//# endif

			# ifdef DT_KERNEL
			float gradgamU = 0;
			# endif

			// loop over all neighbors
			for(uint i = 0; i < d_maxneibsnum_time_neibindexinterleave ; i += NEIBINDEX_INTERLEAVE) {
				uint neib_index = neibsList[d_maxneibsnum_time_neibindexinterleave*lane + i + offset];

				if (neib_index == 0xffffffff) break;

				float4 neib_pos;
				float3 relPos;
				float r;

				#if( __COMPUTE__ >= 20)							
				getNeibData<periodicbound>(pos, posArray, influenceradius, neib_index, neib_pos, relPos, r);
				#else
				getNeibData<periodicbound>(pos, influenceradius, neib_index, neib_pos, relPos, r);
				#endif

				const float4 neib_vel = tex1Dfetch(velTex, neib_index);
				const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);
				# ifdef VISC_KEPS
				const float neib_keps_k = tex1Dfetch(keps_kTex, neib_index);
				const float neib_keps_e = tex1Dfetch(keps_eTex, neib_index);
				const float neib_tvisc = 0.09f*neib_keps_k*neib_keps_k/neib_keps_e;
				# endif

				if (r < influenceradius) {
					float DvDt = 0.0f;
					float4 bound_term_pres = make_float4(0.0f);
					float3 bound_term_visc = make_float3(0.0f);

					if (FLUID(neib_info) || (boundarytype == MF_BOUNDARY && (BOUNDARY(neib_info) || VERTEX(neib_info)) ) ) {
						const float4 belem = tex1Dfetch(boundTex, neib_index);
						const float neib_sspeed = soundSpeed(neib_vel.w, PART_FLUID_NUM(neib_info));

						float neib_pres = tex1Dfetch(presTex, neib_index);
						if(FLUID(neib_info))
							neib_pres = P(neib_vel.w, PART_FLUID_NUM(neib_info));

						# ifdef VISC_SPS
						sym33mat neib_tau;
						temp = tex1Dfetch(tau0Tex, neib_index);
						neib_tau.a11 = temp.x;
						neib_tau.a12 = temp.y;
						temp = tex1Dfetch(tau1Tex, neib_index);
						neib_tau.a13 = temp.x;
						neib_tau.a22 = temp.y;
						temp = tex1Dfetch(tau2Tex, neib_index);
						neib_tau.a23 = temp.x;
						neib_tau.a33 = temp.y;
						# endif

						float3 relVel;
						relVel.x = vel.x - neib_vel.x;
						relVel.y = vel.y - neib_vel.y;
						relVel.z = vel.z - neib_vel.z;

						const float vel_dot_pos = dot(relVel, relPos);	// x.u
						const float f = F<kerneltype>(r, slength);		// 1/r dW/dr

						// density derivative
						float DrDt = 0;
						if(BOUNDARY(neib_info))
							DrDt -= neib_vel.w*dot(relVel, make_float3(gradGamma<kerneltype>(slength, r, belem)) );
						else if(d_ferrari) {
							//P_a' = P_a - rho_0*g*(z_b-z_a)
							const float pres_a_prime = P(vel.w, PART_FLUID_NUM(info)) - d_rho0[PART_FLUID_NUM(info)]*dot(d_gravity, relPos);
							//rho_a' = inverted_EoS(P_a')
							const float rho_a_prime = rho(pres_a_prime, PART_FLUID_NUM(info));
							float3 ferraricor = max(sspeed, neib_sspeed)*(rho_a_prime - neib_vel.w)/vel.w/r*relPos;
							DrDt = neib_pos.w*dot(relVel + d_ferrari*ferraricor, relPos)*f;
						}
						else
							DrDt = neib_pos.w*vel_dot_pos*f;
						/* The second formulation takes into consideration the density ratio */
						if (sph_formulation == SPH_F2)
							DrDt *= vel.w/neib_vel.w;
						if(boundarytype == MF_BOUNDARY) {
							DrDt /= gradgamma.w;
						}
						force.w += DrDt;

						// pressure part of acceleration (to be multiplied by neib_mass*f)
						switch (sph_formulation) {
							case SPH_F1:
								DvDt = -(p_precalc + neib_pres/(neib_vel.w*neib_vel.w)); /*I think these are i not index*/
								# ifdef VISC_KEPS
								DvDt -= 2*neib_keps_k/neib_vel.w/3.f;
								# endif
								break;
							case SPH_F2:
								DvDt = -(p_precalc + P(neib_vel.w, PART_FLUID_NUM(neib_info)))/(vel.w*neib_vel.w);
								break;
						}

						/* Viscous forces */
						# if defined(VISC_DYNAMIC) || defined(VISC_KINEMATIC) || defined(VISC_SPS) || defined(VISC_KEPS)
						# if defined(VISC_DYNAMIC)
						const float visc = laminarvisc_dynamic(vel.w, neib_vel.w, neib_pos.w, f, d_visccoeff*vel.w,
										d_visccoeff*neib_vel.w);
						# elif defined(VISC_KINEMATIC)
						const float visc = laminarvisc_kinematic(vel.w, neib_vel.w, neib_pos.w, f);
						# elif defined(VISC_SPS)
						const float visc = laminarvisc_kinematic(vel.w, neib_vel.w, neib_pos.w, f);
						force.x += neib_pos.w*f*((tau.a11 + neib_tau.a11)*relPos.x + (tau.a12 + neib_tau.a12)*relPos.y +
										(tau.a13 + neib_tau.a13)*relPos.z);
						force.y += neib_pos.w*f*((tau.a12 + neib_tau.a12)*relPos.x + (tau.a22 + neib_tau.a22)*relPos.y +
										(tau.a23 + neib_tau.a23)*relPos.z);
						force.z += neib_pos.w*f*((tau.a13 + neib_tau.a13)*relPos.x + (tau.a23 + neib_tau.a23)*relPos.y +
										(tau.a33 + neib_tau.a33)*relPos.z);
						# elif defined(VISC_KEPS)
						const float visc = laminarvisc_dynamic(vel.w, neib_vel.w, neib_pos.w, f, (d_visccoeff+turbVisc)*vel.w,
										(d_visccoeff+neib_tvisc)*neib_vel.w);
						# endif // VISC_DYNAMIC + elif*

						if(!BOUNDARY(neib_info))
						if(boundarytype == MF_BOUNDARY) {
							force.x += visc*relVel.x/gradgamma.w;
							force.y += visc*relVel.y/gradgamma.w;
							force.z += visc*relVel.z/gradgamma.w;
						}
						else {
							force.x += visc*relVel.x;
							force.y += visc*relVel.y;
							force.z += visc*relVel.z;
						}

						# elif defined(VISC_ARTVISC)
						if (vel_dot_pos < 0.0f)
							DvDt += artvisc(vel_dot_pos, vel.w, neib_vel.w, sspeed, 
										neib_sspeed, r, slength);
						# else
						# error Unknown viscosity!
						# endif // VISC_*

						# ifdef XSPH_KERNEL
						mean_vel -= neib_pos.w*W<kerneltype>(r, slength)*relVel/(vel.w + neib_vel.w);
						# endif

						if(boundarytype == MF_BOUNDARY) {
							if(BOUNDARY(neib_info)) {
								const float4 gradgam_as = gradGamma<kerneltype>(slength, r, belem);
								const float abs_gradgam_as = length(make_float3(gradgam_as));
								bound_term_pres = DvDt*neib_vel.w*gradgam_as;

								// normal vector
								const float3 normal_s = make_float3(belem.x, belem.y, belem.z);
								// r_as - distance between fluid particle and boundary element along the normal
								float r_as = dot(relPos, normal_s);
								if (r_as < deltap)
									r_as = deltap;

								// velocity of fluid particle along the wall
								const float3 vel_tau = relVel - dot(relVel, normal_s)*normal_s;

								// These two expressions are correct only when used together with DYNAMICVISC or KEPSVISC model
								# ifdef VISC_KEPS
								// a component of fluid paricle velocity tangential to the wall
								const float3 u_t = make_float3(vel) - dot(make_float3(vel), normal_s)*normal_s;
								const float abs_u_t = length(u_t);
								float y_plus = deltap;

								// we solve iteratively the wall law equation to obtain y+ value
								float u_star = exp(-2.132f)*d_visccoeff/r_as;
								for(int i=0; i<10; i++) {
									y_plus = max(r_as*u_star/d_visccoeff, 11.f);
									u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
								}
								y_plus = max(r_as*u_star/d_visccoeff, 11.f);

								const float denom_term = pow(log(y_plus)/0.41f + 5.2, 2);
								bound_term_visc = 2*vel.w*abs_u_t*abs_gradgam_as*u_t/denom_term;
								# else
								bound_term_visc = length(gradgam_as)*d_visccoeff*(vel.w + neib_vel.w)/r_as*vel_tau;
								# endif

								//DEBUG output
//								if (length(bound_term_visc) > length(bound_term_pres))
//								printf("Utau_x: %g, Utau_y: %g, Utau_z %g\n", bound_term_visc.x, bound_term_visc.y, bound_term_visc.z);

								# ifdef VISC_KEPS
								//to be divided later by rho_a and gamma_a
								diff_term_e += pow(0.09f, 0.75f)/0.41f * (dedt_precalc*pow(keps_k,1.5f)/(r_as*r_as) +
											neib_vel.w*(d_visccoeff + neib_tvisc/1.3f)*pow(neib_keps_k,1.5f)/(deltap*deltap)) * abs_gradgam_as;
								# endif

								# ifdef DT_KERNEL
								float tmp = abs(dot(make_float3(gradgam_as.x, gradgam_as.y, gradgam_as.z), make_float3(vel.x, vel.y, vel.z)));
								if (tmp > gradgamU)
									gradgamU = tmp;
								# endif
							}
							# ifdef VISC_KEPS
							else {
								//to be divided later by rho_a and gamma_a
								diff_term_k += neib_pos.w*(dkdt_precalc + neib_vel.w*(d_visccoeff + neib_tvisc))*(keps_k - neib_keps_k)*f/neib_vel.w;
								diff_term_e += neib_pos.w*(dedt_precalc + neib_vel.w*(d_visccoeff + neib_tvisc/1.3f))*(keps_e - neib_keps_e)*f/neib_vel.w;
							}
							# endif
						} // endif (boundarytype)
						
						DvDt *= neib_pos.w*f;
					} else
					switch (boundarytype) {
						case LJ_BOUNDARY:
							DvDt = LJForce(r);
							break;
						case MK_BOUNDARY:
							DvDt = MKForce(r, slength, pos.w, pos.w);
							break;
						case MF_BOUNDARY:
							break;
						default:
							DvDt = 1.0/0.0;
					}
					// interaction between two particles
					if(boundarytype == MF_BOUNDARY) {
						if(BOUNDARY(neib_info)) {
							force.x -= bound_term_pres.x/gradgamma.w + bound_term_visc.x/gradgamma.w/vel.w;
							force.y -= bound_term_pres.y/gradgamma.w + bound_term_visc.y/gradgamma.w/vel.w;
							force.z -= bound_term_pres.z/gradgamma.w + bound_term_visc.z/gradgamma.w/vel.w;
						}
						else {
							force.x += DvDt*relPos.x/gradgamma.w;
							force.y += DvDt*relPos.y/gradgamma.w;
							force.z += DvDt*relPos.z/gradgamma.w;
						}
					}
					else {
						force.x += DvDt*relPos.x;
						force.y += DvDt*relPos.y;
						force.z += DvDt*relPos.z;
					}

				} // r < influenceradius
			} // end of loop over neighbors

			# ifdef VISC_DYNAMIC
			const float dynvisc = d_visccoeff*vel.w;
			# elif defined(VISC_KINEMATIC) || defined(VISC_SPS)
			const float dynvisc = d_visccoeff*vel.w/4.0f;				// FXME: check????????
			# elif defined(VISC_ARTVISC)
			const float dynvisc = 0.0;
			# elif defined(VISC_KEPS)
			const float dynvisc = 0.0;

			float dkdt = Pturb - keps_e + diff_term_k/vel.w/gradgamma.w;								// dk/dt
			float dedt = keps_e/keps_k*(1.44f*Pturb - 1.92f*keps_e) + diff_term_e/vel.w/gradgamma.w;	// de/dt

			keps_dkde[index].x = dkdt;
			keps_dkde[index].y = dedt;
			# else
			# error Unknown viscosity!
			# endif

			// gravity
			force.x += d_gravity.x;
			force.y += d_gravity.y;
			force.z += d_gravity.z;

			// TODO: check for time step limitation in case of geometrical boundaries (DEM or planes)
			// for viscous fluids
			float geom_coeff = 0.0f;

			// Adding repulsive force computed from DEM
			if (usedem) {
				switch (boundarytype) {
					case LJ_BOUNDARY:
						geom_coeff = DemLJForce(demTex, pos, make_float3(vel), dynvisc, force);
						break;
					default:
						break;
				}
			}

			// Adding repulsive force computed from geometric boundaries
			if (d_numplanes) {
				geom_coeff = max(geom_coeff, GeometryForce(pos, make_float3(vel), dynvisc, force));
			}
			
			# ifdef DT_KERNEL
			// storing data for cfl condition in shared memory			
			sm_max[threadIdx.x] = max(length(make_float3(force.x, force.y, force.z)), sspeed*sspeed/slength);
			if(boundarytype == MF_BOUNDARY)
				sm_max_g[threadIdx.x] = gradgamU;
			# ifdef VISC_KEPS
			sm_max_nut[threadIdx.x] = turbVisc;
			# endif
			# endif

			# ifdef XSPH_KERNEL
			xsph[index] = make_float4(2.0f*mean_vel, 0.0f);
			# endif

			forces[index] = force;
		}	// if (FLUID(info))

		else if (VERTEX(info)) {
			float4 force = make_float4(0.0f);

			// It is suggested that k-e model is working only with semi-analytical boundary model.
			// Add addtional condition on boundary_type if it isn't.
			# ifdef VISC_KEPS

			// read other particle data from textures or global mem
			#if( __COMPUTE__ >= 20)
			const float4 pos = posArray[index];
			#else
			const float4 pos = tex1Dfetch(posTex, index);
			#endif
			const float4 vel = tex1Dfetch(velTex, index);
			const float4 gradgamma = tex1Dfetch(gamTex, index);

			const float keps_k = tex1Dfetch(keps_kTex, index);
			const float keps_e = tex1Dfetch(keps_eTex, index);
			const float turbVisc = 0.09f*keps_k*keps_k/keps_e;			// eddy viscosity

			// loop over all neighbors
			for(uint i = 0; i < d_maxneibsnum_time_neibindexinterleave ; i += NEIBINDEX_INTERLEAVE) {
				uint neib_index = neibsList[d_maxneibsnum_time_neibindexinterleave*lane + i + offset];

				if (neib_index == 0xffffffff) break;

				float4 neib_pos;
				float3 relPos;
				float r;

				#if( __COMPUTE__ >= 20)
				getNeibData<periodicbound>(pos, posArray, influenceradius, neib_index, neib_pos, relPos, r);
				#else
				getNeibData<periodicbound>(pos, influenceradius, neib_index, neib_pos, relPos, r);
				#endif

				const float4 neib_vel = tex1Dfetch(velTex, neib_index);
				const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);
				const float neib_keps_k = tex1Dfetch(keps_kTex, neib_index);
				const float neib_keps_e = tex1Dfetch(keps_eTex, neib_index);
				const float neib_tvisc = 0.09f*neib_keps_k*neib_keps_k/neib_keps_e;

				if (r < influenceradius) {
					if (BOUNDARY(neib_info)) {
						const float4 belem = tex1Dfetch(boundTex, neib_index);
						const float3 normal_s = make_float3(belem.x, belem.y, belem.z);	// normal vector
						// r_es - distance between vertex particle and boundary element along the normal
						float r_es = dot(relPos, normal_s);
						if (r_es < deltap)
							r_es = deltap;

						const float abs_gradgam_es = length(gradGamma<kerneltype>(slength, r, belem));

						// velocity of vertex particle along the wall
						const float3 u_t = make_float3(vel) - dot(make_float3(vel), normal_s)*normal_s; //FIXME: check which velocity should be used here
						const float abs_u_t = length(u_t);
						float y_plus = deltap;

						// we solve iteratively the wall law equation to obtain y+ value
						float u_star = exp(-2.132f)*d_visccoeff/r_es;
						for(int i=0; i<10; i++) {
							y_plus = max(r_es*u_star/d_visccoeff, 11.f);
							u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
						}
						y_plus = max(r_es*u_star/d_visccoeff, 11.f);

						const float denom_term = pow(log(y_plus)/0.41f + 5.2, 2)*gradgamma.w;

						force.x -= 2*abs_u_t*abs_gradgam_es*u_t.x/denom_term;
						force.y -= 2*abs_u_t*abs_gradgam_es*u_t.y/denom_term;
						force.z -= 2*abs_u_t*abs_gradgam_es*u_t.z/denom_term;
					}
					else {
						float3 relVel;
						relVel.x = vel.x - neib_vel.x;
						relVel.y = vel.y - neib_vel.y;
						relVel.z = vel.z - neib_vel.z;

						const float vel_dot_pos = dot(relVel, relPos);	// x.u
						const float f = F<kerneltype>(r, slength);		// 1/r dW/dr
						const float visc = laminarvisc_dynamic(vel.w, neib_vel.w, neib_pos.w, f, (d_visccoeff+turbVisc)*vel.w,
										(d_visccoeff+neib_tvisc)*neib_vel.w);

						force.x += visc*relVel.x/gradgamma.w;
						force.y += visc*relVel.y/gradgamma.w;
						force.z += visc*relVel.z/gradgamma.w;
					} //end if BOUNDARY(neib_info)
				} // r < influenceradius
			} // end of loop over neighbors

			# endif

			forces[index] = force;
////DEBUG OUTPUT
//			if(index == 8732) {
//				printf("%d\n", index);
//				printf("\tgamma = %g\n", gradgamma.w);
//				printf("\tk = %g\n", keps_k);
//				printf("\te = %g\n", keps_e);
//				printf("\ttvisc = %g\n", turbVisc);
//				printf("\tforce.x = %g\n", force.x);
//				printf("\tforce.y = %g\n", force.y);
//				printf("\tforce.z = %g\n", force.z);
//				printf("\tforce.w = %g\n", force.w);
//			}
		}

		else if (OBJECT(info)) {
			float4 force = make_float4(0.0f);

			// read other particle data from textures or global mem
			#if( __COMPUTE__ >= 20)
			const float4 pos = posArray[index];
			#else
			const float4 pos = tex1Dfetch(posTex, index);
			#endif

			// loop over all neighbors
			for(uint i = 0; i < d_maxneibsnum_time_neibindexinterleave ; i += NEIBINDEX_INTERLEAVE) {
				uint neib_index = neibsList[d_maxneibsnum_time_neibindexinterleave*lane + i + offset];

				if (neib_index == 0xffffffff) break;

				float4 neib_pos;
				float3 relPos;
				float r;
				
				#if( __COMPUTE__ >= 20)							
				getNeibData<periodicbound>(pos, posArray, influenceradius, neib_index, neib_pos, relPos, r);
				#else
				getNeibData<periodicbound>(pos, influenceradius, neib_index, neib_pos, relPos, r);
				#endif

				const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);

				// TODO: improve multi objects
				if (r < influenceradius) {
					float DvDt = 0.0;

					if (FLUID(neib_info) && !OBJECT(neib_info))
						DvDt = neib_pos.w*LJForce(r);
					if (OBJECT(neib_info) && (object(info) != object(neib_info)))
						DvDt = d_objectobjectdf*LJForce(r);		// TODO: apply friction between objects
					if (BOUNDARY(neib_info))
						DvDt = d_objectboundarydf*LJForce(r);		// TODO: choose a better ceofficient ?

					force.x += DvDt*relPos.x;
					force.y += DvDt*relPos.y;
					force.z += DvDt*relPos.z;
				}
			}

			uint rbindex = id(info) + d_rbstartindex[object(info)];
			rbforces[rbindex] = force;
			rbtorques[rbindex] = make_float4(cross(as_float3(pos) - d_rbcg[object(info)], as_float3(force)));;
		} // else if (OBJECT(info))
	}	// if index < numParticles)

	# ifdef DT_KERNEL
	dtadaptBlockReduce(sm_max, cfl);
	if(boundarytype == MF_BOUNDARY)
		dtadaptBlockReduce(sm_max_g, cflGamma);
	# ifdef VISC_KEPS
	dtadaptBlockReduce(sm_max_nut, cfltvisc);
	# endif
	# endif
}
/************************************************************************************************************/

#undef FORCES_CUDA_KERNEL

/* vi:set ft=cuda: */
