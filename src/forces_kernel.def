/*  Copyright 2011-2013 Alexis Herault, Giuseppe Bilotta, Robert A. Dalrymple, Eugenio Rustico, Ciro Del Negro

    Istituto Nazionale di Geofisica e Vulcanologia
        Sezione di Catania, Catania, Italy

    Università di Catania, Catania, Italy

    Johns Hopkins University, Baltimore, MD

    This file is part of GPUSPH.

    GPUSPH is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GPUSPH is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GPUSPH.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <vector_types.h>

/* Auxiliary device functions used in forces kernel. These must only be defined _once_, so fence them */
#ifndef _FORCES_KERNEL_AUX
#define _FORCES_KERNEL_AUX

/// Precompute pressure contribution to the momemntum equation.
/// Two versions are available, one in the KEPS viscosity case,
/// and a generic one

// Generic:
template<SPHFormulation sph_formulation>
__device__ __forceinline__
float
precalc_pressure(const float rho, particleinfo const& info);

/* when using SPH formulation 1, the precomputed pressure contribution
   for the current particle is p/rho^2 */
template<>
__device__ __forceinline__
float
precalc_pressure<SPH_F1>(const float rho, particleinfo const& info)
{
	return P(rho, PART_FLUID_NUM(info))/(rho*rho);
}

/* when using SPH formulation 2, the precomputed pressure contribution
   for the current particle is just p */
template<>
__device__ __forceinline__
float
precalc_pressure<SPH_F2>(const float rho, particleinfo const& info)
{
	return P(rho, PART_FLUID_NUM(info));
}

// With KEPS visc
template<SPHFormulation sph_formulation>
__device__ __forceinline__
float
precalc_pressure(const float rho, particleinfo const& info, const float keps_k)
{
	// in case of k-e model we use p~ = p + 2/3*rho*k
	// TODO FIXME so far this has only be done for SPH_F1,
	// check if this is also valid for SPH_F2
	return precalc_pressure<sph_formulation>(rho, info) + 2*keps_k/rho/3;
}

/* Compute the square of the at-rest speed of sound */
__device__ __forceinline__
float
get_sqC0(particleinfo const& info)
{
	float c0 = d_sscoeff[PART_FLUID_NUM(info)];
	return c0*c0;
}

#endif

// the rest is included multiple times, so no fencing

#ifdef XSPH_KERNEL
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph,)
#	endif
#else
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,,)
#	endif
#endif

/************************************************************************************************************/
/*		   Kernels for computing forces with the different options											*/
/************************************************************************************************************/
template<KernelType kerneltype,
	SPHFormulation sph_formulation,
	BoundaryType boundarytype,
#if 0 // TODO FIXME not yet
	ViscosityType visctype,
	bool dyndt,
	bool usexsph,
#endif
	bool usedem>
__global__ void
FORCES_CUDA_KERNEL(
	forces_params<kerneltype, boundarytype, VISC_TYPE,
#ifdef DT_KERNEL
	true,
#else
	false,
#endif
#ifdef XSPH_KERNEL
	true
#else
	false
#endif
	> params)
{
	// Global particle index
	const uint index = INTMUL(blockIdx.x,blockDim.x) + threadIdx.x;
	# ifdef DT_KERNEL
	__shared__ float sm_max[BLOCK_SIZE_FORCES];
	sm_max[threadIdx.x] = 0.0f;
	# ifdef VISC_KEPS
	__shared__ float sm_max_nut[BLOCK_SIZE_FORCES];
	sm_max_nut[threadIdx.x] = 0.0f;
	# endif
	# endif

	// the body of this kernel easily gets a lot of indentation. to prevent that,
	// we wrap the main part into a do { } while(0); so that rather than
	// if (c1) { if (c2) { if (c3) { stuff } } } we can do
	// if (!c1) break; if (!c2) break ; if (!c3) break; stuff
	// to do stuff only if c1, c2, c3 are satisfied.
	// This makes the code more readable and collects common data retrieval operations
	// into one place.
	// (The alternative would have been a label before the reduction and a
	// bunch of goto label, but that would skip across initializations, which is an error.
	// and some people still don't like gotos, so this is actually a better alternative).
#pragma unroll
	do {
		if (index >= params.numParticles)
			break;

		// particle info struct, always stored in a texture
		const particleinfo info = tex1Dfetch(infoTex, index);

		// Determine if the current particle must act based on the particle type.
		// The particles for which forces are computed are:
		// * fluid particles
		// * object particles
		// * vertex particles (for SA_BOUNDARY)

		bool computes_stuff = FLUID(info) || OBJECT(info);
		if (boundarytype == SA_BOUNDARY)
			computes_stuff = computes_stuff || VERTEX(info);

		// nothing to do if the particle doesn't need to compute forces
		if (!computes_stuff)
			break;

		// cell-local position of the particle, stored in texture
		// or global memory depending on architecture
		#if( __COMPUTE__ >= 20)
		const float4 pos = params.posArray[index];
		#else
		const float4 pos = tex1Dfetch(posTex, index);
		#endif

		// nothing to do if the particle is inactive
		if (INACTIVE(pos))
			break;

		// TODO only used for objects
		const uint rbindex = id(info) + d_rbstartindex[object(info)];

		// grid (cell) coordinates of current particle
		const int3 gridPos = calcGridPosFromParticleHash(params.particleHash[index]);

		// particle velocity
		// TODO for vertex particles it's only needed for KEPSVISC
		// TODO for object particles it's not used
		const float4 vel = tex1Dfetch(velTex, index);

		// speed of sound
		// TODO this is only used for dyndt, ARTVISC, SA_BOUNDARY
		const float sspeed = soundSpeed(vel.w, PART_FLUID_NUM(info));

		// square of at-rest sound speed. Would need modifications for multifluid
		// TODO this should be computed once on the host and loaded into constant memory
		// TODO only used for SA_BOUNDARY
		const float sqC0 = get_sqC0(info);

		// TODO the next two are only needed for SA_BOUNDARY
		// TODO for object particles it's not used (currently)

		// oldGGam would hold the previous value of gamma (in .w) and its gradient (in .xyz).
		// When we want to (re)compute gamma, the old gradient is only used for
		// the computation of solid angles for gamma, for which we actually
		// need the opposite, normalized vector. In this case, when loading
		// oldGGam we therefore proceed to the normalization and sign-change of
		// the gradient part, preserving .w

		// For fluid particles, we always want to recompute gamma, while for
		// vertex particles we only want to recompute if we have moving
		// boundaries or if gamma itself has not been computed before, where ‘computed before’
		// is assessed by checking if its value is less than the given epsilon
		bool computeGamma = FLUID(info) || (VERTEX(info) && params.movingBoundaries);

		// the actual oldGGam loading: this will also set computeGamma true if it was
		// false but .w was < epsilon
		const float4 oldGGam = (boundarytype == SA_BOUNDARY) ?
			fetchNormalizedOldGamma(index, params.epsilon, computeGamma) :
			make_float4(NAN);
		// now oldGGam holds the old value of gamma if computeGamma == false,
		// and the renormalized gradient in .xyz if computeGamma == true

		# ifdef VISC_SPS
		// particle SPS matrix
		// TODO only used for fluid particles
		const symtensor3 tau(fetchTau(index));
		# endif

		// TODO the next group of variables isn't used for object particles
		# ifdef VISC_KEPS
		const float keps_k = tex1Dfetch(keps_kTex, index);
		const float keps_e = tex1Dfetch(keps_eTex, index);
		// eddy viscosity, 0 on boundary
		const float turbVisc = FLUID(info) ? 0.09f*keps_k*keps_k/keps_e : 0;

		// TODO only used for fluid particles
		const float dkdt_precalc = vel.w*(d_visccoeff + turbVisc);
		const float dedt_precalc = vel.w*(d_visccoeff + turbVisc/1.3f);
		# endif

		/* precomputed component of pressure contribution to the momentum equation */
		const float p_precalc =
#ifdef VISC_KEPS
			precalc_pressure<sph_formulation>(vel.w, info, keps_k);
#else
			precalc_pressure<sph_formulation>(vel.w, info);
#endif

		/* From here on, we have output variables */

		// force and density derivative
		float4 force = make_float4(0);

		// new value of gamma and grad gamma
		// TODO only if boundarytype == SA_BOUNDARY
		float4 gGam = make_float4(0.0f, 0.0f, 0.0f, 1.0f);

		// TODO this block of output variables is only used
		// for fluid particles
		# ifdef VISC_KEPS
		// velocity gradient components
		float3 dvx = make_float3(0.0f);
		float3 dvy = make_float3(0.0f);
		float3 dvz = make_float3(0.0f);

		float diff_term_k = 0;
		float diff_term_e = 0;
		# endif

		// TODO fluid particles only
		# ifdef XSPH_KERNEL
		// XSPH correction
		float3 mean_vel = make_float3(0.0f);
		# endif

		/* And finally the neib list transversal support */

		// persistent variables across getNeibData calls
		char neib_cellnum = 0;
		uint neib_cell_base_index = 0;
		float3 pos_corr;

		// we need to special-case VERTEX particles, since they only loop
		// through neighbors if computeGamma is true or KEPSVISC, so we
		// initialize the loop counter here. Setting it to d_neiblist_end
		// will allow us to skip the loop
		idx_t i = 0;
		if (boundarytype == SA_BOUNDARY && VERTEX(info) && !computeGamma && VISC_TYPE != KEPSVISC) {
			gGam = oldGGam;
			i = d_neiblist_end; // skip neighbors loop
		}

		// loop over all neighbors
		for (; i < d_neiblist_end; i += d_neiblist_stride) {
			neibdata neib_data = params.neibsList[i + index];

			if (neib_data == 0xffff) break;

			const uint neib_index = getNeibIndex(pos, pos_corr, params.cellStart,
				neib_data, gridPos, neib_cellnum, neib_cell_base_index);

			// Compute relative position vector and distance
			// Now relPos is a float4 and neib mass is stored in relPos.w
			#if( __COMPUTE__ >= 20)
			const float4 relPos = pos_corr - params.posArray[neib_index];
			#else
			const float4 relPos = pos_corr - tex1Dfetch(posTex, neib_index);
			#endif

			// skip inactive particles
			if (INACTIVE(relPos))
				continue;

			const float r = length3(relPos);

			const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);

			// we now check if the current particle interacts with the neighbor.
			// We recycle the computes_stuff as boolean
			computes_stuff = (r < params.influenceradius);

			// Objects only interact with fluid particles, since object-object
			// and object-boundary forces are computed with ODE
			if (OBJECT(info))
				computes_stuff = computes_stuff && (FLUID(neib_info) && !OBJECT(neib_info));

			// with SA_BOUNDARY, fluid and vertex particles interact with any
			// BOUNDARY particles in the neiblist, regardless of distance
			// TODO FIXME they should interact with BOUNDARY particles such
			// that the current particle influence radius intersects the
			// boundary element
			if (boundarytype == SA_BOUNDARY && (FLUID(info) || VERTEX(info)))
				computes_stuff = computes_stuff || BOUNDARY(neib_info);

			// bail out if we do not interact with this neighbor
			if (!computes_stuff)
				continue;

			// Compute relative velocity
			// Now relVel is a float4 and neib density is stored in relVel.w
			const float4 relVel = as_float3(vel) - tex1Dfetch(velTex, neib_index);

			// x.u
			const float vel_dot_pos = dot3(relVel, relPos);
			// 1/r dW/dr
			const float f = F<kerneltype>(r, params.slength);

			# ifdef VISC_SPS
			// neighbor SPS matrix
			// TODO only used for fluid particles
			const symtensor3 neib_tau(fetchTau(neib_index));
			# endif

			// TODO the next group of variables isn't used for object particles
			# ifdef VISC_KEPS
			const float neib_keps_k = tex1Dfetch(keps_kTex, neib_index);
			const float neib_keps_e = tex1Dfetch(keps_eTex, neib_index);
			const float neib_tvisc = FLUID(neib_info) ?
				0.09f*neib_keps_k*neib_keps_k/neib_keps_e : 0;
			# endif

			// TODO only if SA_BOUNDARY
			const float4 belem = (boundarytype == SA_BOUNDARY ? tex1Dfetch(boundTex, neib_index) : make_float4(NAN));
			const float neib_sspeed = soundSpeed(relVel.w, PART_FLUID_NUM(neib_info));

			/* Contributions from this neighbor */

			// acceleration, gets multiplied by relPos.xyz
			float DvDt = 0;
			// density derivative
			float DrDt = 0;

			/* Now compute the interactions based on info and neib_info */

			if (FLUID(info)) {
				// TODO only if SA_BOUNDARY
				float3 bound_term_pres = make_float3(0.0f);
				float3 bound_term_visc = make_float3(0.0f);
				// grad gamma_{as}
				float2 gamAS = make_float2(0);

				if (FLUID(neib_info) || (boundarytype == SA_BOUNDARY && (BOUNDARY(neib_info) || VERTEX(neib_info)) ) ) {
					// compute DrDt and gamAS contributions
					if (boundarytype == SA_BOUNDARY && BOUNDARY(neib_info)) {
						gamAS = Gamma<kerneltype>(params.slength, relPos, params.vertPos0[neib_index], params.vertPos1[neib_index], params.vertPos2[neib_index], belem, oldGGam, params.epsilon, true);
						gGam.x += gamAS.x*belem.x;
						gGam.y += gamAS.x*belem.y;
						gGam.z += gamAS.x*belem.z;
						gGam.w -= gamAS.y;
						DrDt -= relVel.w*dot3(relVel, belem)*gamAS.x;
					} else if (boundarytype == SA_BOUNDARY && d_ferrari) {
						const float grav_corr = -dot(d_gravity, as_float3(relPos))*d_rho0[PART_FLUID_NUM(info)]/sqC0;
						float3 ferraricor = (r > 1e-4*params.slength) ? max(sspeed, neib_sspeed)*(vel.w - relVel.w + grav_corr)/vel.w/r*as_float3(relPos) : make_float3(0.0);
						DrDt = relPos.w*dot(as_float3(relVel) + d_ferrari*ferraricor, as_float3(relPos))*f;
					} else
						DrDt = relPos.w*vel_dot_pos*f;
					/* The second formulation takes into consideration the density ratio */
					if (sph_formulation == SPH_F2)
						DrDt *= vel.w/relVel.w;
					force.w += DrDt;

					// pressure part of acceleration (to be multiplied by neib_mass*f)
					switch (sph_formulation) {
						case SPH_F1:
							DvDt = -(p_precalc + P(relVel.w, PART_FLUID_NUM(neib_info))/(relVel.w*relVel.w));
							# ifdef VISC_KEPS
							DvDt -= 2*neib_keps_k/relVel.w/3.f;
							# endif
							break;
						case SPH_F2:
							DvDt = -(p_precalc + P(relVel.w, PART_FLUID_NUM(neib_info)))/(vel.w*relVel.w);
							break;
					}

					/* Viscous forces */
					# if defined(VISC_DYNAMIC) || defined(VISC_KINEMATIC) || defined(VISC_SPS) || defined(VISC_KEPS)
					# if defined(VISC_DYNAMIC)
					const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, d_visccoeff*vel.w,
									d_visccoeff*relVel.w);
					# elif defined(VISC_KINEMATIC)
					const float visc = laminarvisc_kinematic(vel.w, relVel.w, relPos.w, f);
					# elif defined(VISC_SPS)
					const float visc = laminarvisc_kinematic(vel.w, relVel.w, relPos.w, f);
					force.x += relPos.w*f*((tau.xx + neib_tau.xx)*relPos.x + (tau.xy + neib_tau.xy)*relPos.y +
									(tau.xz + neib_tau.xz)*relPos.z);
					force.y += relPos.w*f*((tau.xy + neib_tau.xy)*relPos.x + (tau.yy + neib_tau.yy)*relPos.y +
									(tau.yz + neib_tau.yz)*relPos.z);
					force.z += relPos.w*f*((tau.xz + neib_tau.xz)*relPos.x + (tau.yz + neib_tau.yz)*relPos.y +
									(tau.zz + neib_tau.zz)*relPos.z);
					# elif defined(VISC_KEPS)
					const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, (d_visccoeff+turbVisc)*vel.w,
									(d_visccoeff+neib_tvisc)*relVel.w);
					# endif // VISC_DYNAMIC + elif*

					if(!BOUNDARY(neib_info)) {
						as_float3(force) += visc*as_float3(relVel);
					}

					# elif defined(VISC_ARTVISC)
					if (vel_dot_pos < 0.0f)
						DvDt += artvisc(vel_dot_pos, vel.w, relVel.w, sspeed,
									soundSpeed(relVel.w, PART_FLUID_NUM(neib_info)), r, params.slength);
					# else
					# error Unknown viscosity!
					# endif // VISC_*

					# ifdef XSPH_KERNEL
					mean_vel -= relPos.w*W<kerneltype>(r, params.slength)*as_float3(relVel)/(vel.w + relVel.w);
					# endif

					if (boundarytype == SA_BOUNDARY) {
						if (BOUNDARY(neib_info)) {
							// normal vector
							const float3 normal_s = as_float3(belem);

							// pressure boundary term
							bound_term_pres = DvDt*relVel.w*gamAS.x*normal_s;

							// r_as - distance between fluid particle and boundary element along the normal
							float r_as = dot(as_float3(relPos), normal_s);
							if (r_as < params.deltap)
								r_as = params.deltap;

							// velocity of fluid particle along the wall
							const float3 vel_tau = as_float3(relVel) - dot(as_float3(relVel), normal_s)*normal_s;

							// These two expressions are correct only when used together with DYNAMICVISC or KEPSVISC model
							# ifdef VISC_KEPS
							// a component of fluid paricle velocity tangential to the wall
							const float3 u_t = as_float3(vel) - dot(as_float3(vel), normal_s)*normal_s;
							const float abs_u_t = length(u_t);
							float y_plus = params.deltap;

							// we solve iteratively the wall law equation to obtain y+ value
							float u_star = exp(-2.132f)*d_visccoeff/r_as;
							for (int i=0; i<10; i++) {
								y_plus = max(r_as*u_star/d_visccoeff, 11.f);
								u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
							}
							y_plus = max(r_as*u_star/d_visccoeff, 11.f);

							const float denom_term = pow(log(y_plus)/0.41f + 5.2f, 2);
							bound_term_visc = 2*vel.w*abs_u_t*gamAS.x*u_t/denom_term;

							// velocity gradient
							const float3 rhoGGam = gamAS.x*normal_s*relVel.w;

							dvx += relVel.x*rhoGGam;	// dvx = ∑ρs vxas ∇ɣas
							dvy += relVel.y*rhoGGam;	// dvy = ∑ρs vyas ∇ɣas
							dvz += relVel.z*rhoGGam;	// dvz = ∑ρs vzas ∇ɣas
							# else
							bound_term_visc = gamAS.x*d_visccoeff*(vel.w + relVel.w)/r_as*vel_tau;
							# endif

							# ifdef VISC_KEPS
							//to be divided later by rho_a and gamma_a
							diff_term_e += pow(0.09f, 0.75f)/0.41f * (dedt_precalc*pow(keps_k,1.5f)/(r_as*r_as) +
										relVel.w*(d_visccoeff + neib_tvisc/1.3f)*pow(neib_keps_k,1.5f)/(params.deltap*params.deltap)) * gamAS.x;
							# endif

						}
						# ifdef VISC_KEPS
						else {
							//to be divided later by rho_a and gamma_a
							diff_term_k += relPos.w*(dkdt_precalc + relVel.w*(d_visccoeff + neib_tvisc))*(keps_k - neib_keps_k)*f/relVel.w;
							diff_term_e += relPos.w*(dedt_precalc + relVel.w*(d_visccoeff + neib_tvisc/1.3f))*(keps_e - neib_keps_e)*f/relVel.w;

							//velocity gradient
							dvx -= relVel.x*as_float3(relPos)*f;	// dvx = -∑mb vxab (ra - rb)/r ∂Wab/∂r
							dvy -= relVel.y*as_float3(relPos)*f;	// dvy = -∑mb vyab (ra - rb)/r ∂Wab/∂r
							dvz -= relVel.z*as_float3(relPos)*f;	// dvz = -∑mb vzab (ra - rb)/r ∂Wab/∂r
						}
						# endif
					} // endif (boundarytype)

					DvDt *= relPos.w*f;
				} else {
					switch (boundarytype) {
						case LJ_BOUNDARY:
							DvDt = LJForce(r);
							break;
						case MK_BOUNDARY:
							DvDt = MKForce(r, params.slength, pos.w, pos.w);
							break;
						case SA_BOUNDARY:
							// TODO FIXME this is currently encountered when the fluid interacts with a floating object
							DvDt = LJForce(r);
							break;
						default:
							DvDt = 1.0f/0.0f;
							break;
					}
				}
				if (boundarytype == SA_BOUNDARY && BOUNDARY(neib_info)) {
					as_float3(force) -= bound_term_pres + bound_term_visc/vel.w;
				} else {
					as_float3(force) += DvDt*as_float3(relPos);
				}
			}
			else if (boundarytype == SA_BOUNDARY && VERTEX(info)) {
				// we only get here if computeGamma || VISC_TYPE == KEPSVISC

				if (BOUNDARY(neib_info)) {
					const float3 normal_s = as_float3(belem);	// normal vector
					# ifdef VISC_KEPS
					// r_es - distance between vertex particle and boundary element along the normal
					float r_es = dot(as_float3(relPos), normal_s);
					if (r_es < params.deltap)
						r_es = params.deltap;
					#endif

					const float2 gamES = Gamma<kerneltype>(params.slength, relPos, params.vertPos0[neib_index], params.vertPos1[neib_index], params.vertPos2[neib_index], belem, oldGGam, params.epsilon, computeGamma);
					if (computeGamma){
						gGam.x += gamES.x*belem.x;
						gGam.y += gamES.x*belem.y;
						gGam.z += gamES.x*belem.z;
						gGam.w -= gamES.y;
					}

					# ifdef VISC_KEPS
					// velocity of vertex particle along the wall
					const float3 u_t = as_float3(vel) - dot(as_float3(vel), normal_s)*normal_s;
					const float abs_u_t = length(u_t);
					float y_plus = params.deltap;

					// we solve iteratively the wall law equation to obtain y+ value
					float u_star = exp(-2.132f)*d_visccoeff/r_es;
					for (int i=0; i<10; i++) {
						y_plus = max(r_es*u_star/d_visccoeff, 11.f);
						u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
					}
					y_plus = max(r_es*u_star/d_visccoeff, 11.f);

					const float denom_term = pow(log(y_plus)/0.41f + 5.2f, 2);

					force.x -= 2*abs_u_t*gamES.x*u_t.x/denom_term;
					force.y -= 2*abs_u_t*gamES.x*u_t.y/denom_term;
					force.z -= 2*abs_u_t*gamES.x*u_t.z/denom_term;
					#endif
				}
				# ifdef VISC_KEPS
				else {
					const float vel_dot_pos = dot(as_float3(relVel), as_float3(relPos));	// x.u
					const float f = F<kerneltype>(r, params.slength);		// 1/r dW/dr
					const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, (d_visccoeff+turbVisc)*vel.w,
									(d_visccoeff+neib_tvisc)*relVel.w);

					force.x += visc*relVel.x;
					force.y += visc*relVel.y;
					force.z += visc*relVel.z;
				} //end if BOUNDARY(neib_info)
				#endif
			}
			else if (OBJECT(info)) {
				DvDt = relPos.w*LJForce(r);

				as_float3(force) += DvDt*as_float3(relPos);
			}
		} // end of loop over neighbors

		// External forces etc
		if (FLUID(info)) {
			# ifdef VISC_DYNAMIC
			const float dynvisc = d_visccoeff*vel.w;
			# elif defined(VISC_KINEMATIC) || defined(VISC_SPS)
			const float dynvisc = d_visccoeff*vel.w/4.0f;				// FXME: check????????
			# elif defined(VISC_ARTVISC)
			const float dynvisc = 0.0f;
			# elif defined(VISC_KEPS)
			const float dynvisc = 0.0f;

			// velocity gradients
			dvx /= vel.w * gGam.w;	// dvx = -1/ɣa*ρa ∑mb vxab (ra - rb)/r ∂Wab/∂r
			dvy /= vel.w * gGam.w;	// dvy = -1/ɣa*ρa ∑mb vyab (ra - rb)/r ∂Wab/∂r
			dvz /= vel.w * gGam.w;	// dvz = -1/ɣa*ρa ∑mb vzab (ra - rb)/r ∂Wab/∂r
			// Calculate norm of the mean strain rate tensor
			float SijSij_bytwo = 2.0f*(dvx.x*dvx.x + dvy.y*dvy.y + dvz.z*dvz.z);	// 2*SijSij = 2.0((∂vx/∂x)^2 + (∂vy/∂yx)^2 + (∂vz/∂z)^2)
			float temp = dvx.y + dvy.x;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vx/∂y + ∂vy/∂x)^2
			temp = dvx.z + dvz.x;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vx/∂z + ∂vz/∂x)^2
			temp = dvy.z + dvz.y;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vy/∂z + ∂vz/∂y)^2
			float S = sqrtf(SijSij_bytwo);
			const float Pturb = turbVisc*S*S;					// production of turbulent kinetic energy (TKE)

			float dkdt = Pturb - keps_e + diff_term_k/vel.w/gGam.w;								// dk/dt
			float dedt = keps_e/keps_k*(1.44f*Pturb - 1.92f*keps_e) + diff_term_e/vel.w/gGam.w;	// de/dt

			params.keps_dkde[index].x = dkdt;
			params.keps_dkde[index].y = dedt;
			# else
			# error Unknown viscosity!
			# endif

			// Dividing by gamma
			if (boundarytype == SA_BOUNDARY){
				gGam.w = fmin(fmax(gGam.w, params.epsilon),1.0f);
				force /= gGam.w;
			}
			// Adding gravity
			as_float3(force) += d_gravity;

			// TODO: check for time step limitation in case of geometrical boundaries (DEM or planes)
			// for viscous fluids
			float geom_coeff = 0.0f;

			// Adding repulsive force computed from DEM
			if (usedem) {
				switch (boundarytype) {
					case LJ_BOUNDARY:
						geom_coeff = DemLJForce(demTex, as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize,
										pos.w, as_float3(vel), dynvisc, force);
						break;
					default:
						break;
				}
			}

			// Adding repulsive force computed from geometric boundaries
			if (d_numplanes) {
				geom_coeff = max(geom_coeff, GeometryForce(d_worldOrigin + as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize,
							pos.w, as_float3(vel), dynvisc, force));
			}

			# ifdef DT_KERNEL
			// storing data for cfl condition in shared memory
			sm_max[threadIdx.x] = max(length(as_float3(force)), sspeed*sspeed/params.slength);
			# ifdef VISC_KEPS
			sm_max_nut[threadIdx.x] = turbVisc;
			# endif
			# endif
		}
		else if (boundarytype == SA_BOUNDARY && VERTEX(info)) {
			gGam.w = fmin(fmax(gGam.w, params.epsilon),1.0f);
			force /= gGam.w;
		}

		// Writing out the results
		if (FLUID(info) || (boundarytype == SA_BOUNDARY && VERTEX(info))) {
			params.forces[index] = force;

			if (boundarytype == SA_BOUNDARY)
				params.newGGam[index] = gGam;
		}

		if (FLUID(info)) {
			# ifdef XSPH_KERNEL
			params.xsph[index] = make_float4(2.0f*mean_vel, 0.0f);
			# endif

			# ifdef VISC_KEPS
			params.turbvisc[index] = turbVisc;
			# endif
		}

		if (OBJECT(info)) {
			params.rbforces[rbindex] = force;
			params.rbtorques[rbindex] = make_float4(cross(d_worldOrigin + as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize
								- d_rbcg[object(info)], as_float3(force)));
		}

	} while (0);

	# ifdef DT_KERNEL
	dtadaptBlockReduce(sm_max, params.cfl);
	# ifdef VISC_KEPS
	dtadaptBlockReduce(sm_max_nut, params.cfltvisc);
	# endif
	# endif
}
/************************************************************************************************************/

#undef FORCES_CUDA_KERNEL

/* vi:set ft=cuda: */
