/*  Copyright 2011-2013 Alexis Herault, Giuseppe Bilotta, Robert A. Dalrymple, Eugenio Rustico, Ciro Del Negro

    Istituto Nazionale di Geofisica e Vulcanologia
        Sezione di Catania, Catania, Italy

    Università di Catania, Catania, Italy

    Johns Hopkins University, Baltimore, MD

    This file is part of GPUSPH.

    GPUSPH is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GPUSPH is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GPUSPH.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <vector_types.h>

#ifdef XSPH_KERNEL
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE, Xsph,)
#	endif
#else
#	ifdef DT_KERNEL
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,, Dt)
#	else
#		define FORCES_CUDA_KERNEL FORCES_KERNEL_NAME(VISC_TYPE,,)
#	endif
#endif

/************************************************************************************************************/
/*		   Kernels for computing forces with the different options											*/
/************************************************************************************************************/
template<KernelType kerneltype, BoundaryType boundarytype, bool usedem,
		 SPHFormulation sph_formulation>
__global__ void
//__launch_bounds__(BLOCK_SIZE_FORCES, MIN_BLOCKS_FORCES)
FORCES_CUDA_KERNEL
(
	const float4*	posArray,
	const float2*	vertPos0,
	const float2*	vertPos1,
	const float2*	vertPos2,
	float4*		newGGam,
	float4*		forces,
	float2*		keps_dkde,
	float*		turbvisc,
	const hashKey*	particleHash,
	const uint*	cellStart,
	# ifdef XSPH_KERNEL
	float4*		xsph,
	# endif
	const neibdata*	neibsList,
	const uint	numParticles,
	const float deltap,
	const float	slength,
	const float	influenceradius,
	const float	epsilon,
	const bool	movingBoundaries,
	float4*		rbforces,
	float4*		rbtorques
	# ifdef DT_KERNEL
	,
	float*		cfl,
	float*		cfltvisc
	# endif
)
{
	// Global particle index
	const uint index = INTMUL(blockIdx.x,blockDim.x) + threadIdx.x;
	# ifdef DT_KERNEL
	__shared__ float sm_max[BLOCK_SIZE_FORCES];
	sm_max[threadIdx.x] = 0.0f;
	# ifdef VISC_KEPS
	__shared__ float sm_max_nut[BLOCK_SIZE_FORCES];
	sm_max_nut[threadIdx.x] = 0.0f;
	# endif
	# endif

	// the body of this kernel easily gets a lot of indentation. to prevent that,
	// we wrap the main part into a do { } while(0); so that rather than
	// if (c1) { if (c2) { if (c3) { stuff } } } we can do
	// if (!c1) break; if (!c2) break ; if (!c3) break; stuff
	// to do stuff only if c1, c2, c3 are satisfied.
	// This makes the code more readable and collects common data retrieval operations
	// into one place.
	// (The alternative would have been a label before the reduction and a
	// bunch of goto label, but that would skip across initializations, which is an error.
	// and some people still don't like gotos, so this is actually a better alternative).
	do {
		if (index >= numParticles)
			break;

		// particle info struct, always stored in a texture
		const particleinfo info = tex1Dfetch(infoTex, index);

		// Determine if the current particle must act based on the particle type.
		// The particles for which forces are computed are:
		// * fluid particles
		// * object particles
		// * vertex particles (for SA_BOUNDARY)

		bool computes_stuff = FLUID(info) || OBJECT(info);
		if (boundarytype == SA_BOUNDARY)
			computes_stuff = computes_stuff || VERTEX(info);
		// TODO there are additional conditions here, see computeGamma boolean
		// under if (boundarytype == SA_BOUNDARY && VERTEX(info))

		// nothing to do if the particle doesn't need to compute forces
		if (!computes_stuff)
			break;

		// cell-local position of the particle, stored in texture
		// or global memory depending on architecture
		#if( __COMPUTE__ >= 20)
		const float4 pos = posArray[index];
		#else
		const float4 pos = tex1Dfetch(posTex, index);
		#endif

		// nothing to do if the particle is inactive
		if (INACTIVE(pos))
			break;

		// grid (cell) coordinates of current particle
		const int3 gridPos = calcGridPosFromParticleHash(particleHash[index]);

		// particle velocity
		// TODO for vertex particles it's only needed for KEPSVISC
		// TODO for object particles it's not used
		const float4 vel = tex1Dfetch(velTex, index);

		// TODO the next group of variables isn't used for object particles
		# ifdef VISC_KEPS
		const float keps_k = tex1Dfetch(keps_kTex, index);
		const float keps_e = tex1Dfetch(keps_eTex, index);
		// eddy viscosity, 0 on boundary
		const float turbVisc = VERTEX(info) ? 0 : 0.09f*keps_k*keps_k/keps_e;
		# endif

		// force and density derivative
		float4 force = make_float4(0);

		// new value of gamma and grad gamma
		// TODO only if boundarytype == SA_BOUNDARY
		float4 gGam = make_float4(0.0f, 0.0f, 0.0f, 1.0f);

		// neighbor list iteration support:
		// persistent variables across getNeibData calls
		char neib_cellnum = 0;
		uint neib_cell_base_index = 0;
		float3 pos_corr;

		// Compute force only if the given particle if a fluid one
		if (FLUID(info)) {

			// oldGGam is used for for the computation of solid angles for gamma. We actually require the inverse vector and we normalize it as all we need are angles
			float4 oldGGam = make_float4(NAN, NAN, NAN, 1.0f);
			if (boundarytype == SA_BOUNDARY) {
				oldGGam = tex1Dfetch(gamTex, index);
				oldGGam /= -length3(oldGGam);
			}

			# ifdef VISC_SPS
			// read particle SPS matrix
			const symtensor3 tau(fetchTau(index));
			# endif

			# ifdef VISC_KEPS
			turbvisc[index] = turbVisc;

			float diff_term_k = 0;
			float diff_term_e = 0;
			const float dkdt_precalc = vel.w*(d_visccoeff + turbVisc);
			const float dedt_precalc = vel.w*(d_visccoeff + turbVisc/1.3f);

			// velocity gradient components
			float3 dvx = make_float3(0.0f);
			float3 dvy = make_float3(0.0f);
			float3 dvz = make_float3(0.0f);
			# endif

			# ifdef XSPH_KERNEL
			// XSPH correction
			float3 mean_vel = make_float3(0.0f);
			# endif

			/* precomputed component of DvDt */
			float p_precalc = 0;
			switch (sph_formulation) {
				/* when using SPH formulation 1
				   we precompute p/rho^2 for the current particle */
				case SPH_F1:
					p_precalc = P(vel.w, PART_FLUID_NUM(info))/(vel.w*vel.w);
					//in case of k-e model we use p~ = p + 2/3*rho*k
					# ifdef VISC_KEPS
					p_precalc += 2*keps_k/vel.w/3.f;
					# endif
					break;
				/* when using SPH formulation 2
				   we precompute the pressure for the current particle */
				case SPH_F2:
					p_precalc = P(vel.w, PART_FLUID_NUM(info));
					break;
			}

			//FIXME: Speed of sound should be calculated with SA_BOUNDARY, even when dt is constant
			//# if defined(DT_KERNEL) || defined(VISC_ARTVISC)
			/* sound speed sspeed is computed only once for the given particle */
			const float sspeed = soundSpeed(vel.w, PART_FLUID_NUM(info));
			// Square of sound speed. Would need modification for multifluid
			float sqC0 = d_sscoeff[PART_FLUID_NUM(info)];
			sqC0 *= sqC0;
			//# endif

			// loop over all neighbors
			for (idx_t i = 0; i < d_neiblist_end; i += d_neiblist_stride) {
				neibdata neib_data = neibsList[i + index];

				if (neib_data == 0xffff) break;

				const uint neib_index = getNeibIndex(pos, pos_corr, cellStart, neib_data, gridPos,
													neib_cellnum, neib_cell_base_index);

				// Compute relative position vector and distance
				// Now relPos is a float4 and neib mass is stored in relPos.w
				#if( __COMPUTE__ >= 20)
				const float4 relPos = pos_corr - posArray[neib_index];
				#else
				const float4 relPos = pos_corr - tex1Dfetch(posTex, neib_index);
				#endif

				// skip inactive particles
				if (INACTIVE(relPos))
					continue;

				const float r = length3(relPos);

				// Compute relative velocity
				// Now relVel is a float4 and neib density is stored in relVel.w
				const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);
				# ifdef VISC_KEPS
				const float neib_keps_k = tex1Dfetch(keps_kTex, neib_index);
				const float neib_keps_e = tex1Dfetch(keps_eTex, neib_index);
				float neib_tvisc;
				if(FLUID(neib_info))
					neib_tvisc = 0.09f*neib_keps_k*neib_keps_k/neib_keps_e;
				else
					neib_tvisc = 0.0f;
				# endif

				if (r < influenceradius || (boundarytype == SA_BOUNDARY && BOUNDARY(neib_info))) {
					float DvDt = 0.0f;
					float3 bound_term_pres = make_float3(0.0f);
					float3 bound_term_visc = make_float3(0.0f);
					// NOTE: this subtraction of float3 - float4 ensures that the .w component
					//       of the float4 remains positive. This implies that relVel.w is equal
					//       to velTex[neib_index].w.
					const float4 relVel = as_float3(vel) - tex1Dfetch(velTex, neib_index);

					if (FLUID(neib_info) || (boundarytype == SA_BOUNDARY && (BOUNDARY(neib_info) || VERTEX(neib_info)) ) ) {
						const float4 belem = (boundarytype == SA_BOUNDARY ? tex1Dfetch(boundTex, neib_index) : make_float4(NAN));
						const float neib_sspeed = soundSpeed(relVel.w, PART_FLUID_NUM(neib_info));

						/* TODO-AM should be removed I suppose
						float neib_pres = tex1Dfetch(presTex, neib_index);
						if(FLUID(neib_info))
							neib_pres = P(relVel.w, PART_FLUID_NUM(neib_info)); */

						# ifdef VISC_SPS
						const symtensor3 neib_tau(fetchTau(neib_index));
						# endif

						const float vel_dot_pos = dot3(relVel, relPos);	// x.u
						const float f = F<kerneltype>(r, slength);		// 1/r dW/dr

						// density derivative
						float DrDt = 0;
						// grad gamma_{as}
						float2 gamAS = make_float2(0.0f);
						if (boundarytype == SA_BOUNDARY && BOUNDARY(neib_info)){
							gamAS = Gamma<kerneltype>(slength, relPos, vertPos0[neib_index], vertPos1[neib_index], vertPos2[neib_index], belem, oldGGam, epsilon, true);
							gGam.x += gamAS.x*belem.x;
							gGam.y += gamAS.x*belem.y;
							gGam.z += gamAS.x*belem.z;
							gGam.w -= gamAS.y;
							DrDt -= relVel.w*dot3(relVel, belem)*gamAS.x;
						}
						else if (boundarytype == SA_BOUNDARY && d_ferrari) {
							const float grav_corr = -dot(d_gravity, as_float3(relPos))*d_rho0[PART_FLUID_NUM(info)]/sqC0;
							float3 ferraricor = (r > 1e-4*slength) ? max(sspeed, neib_sspeed)*(vel.w - relVel.w + grav_corr)/vel.w/r*as_float3(relPos) : make_float3(0.0);
							DrDt = relPos.w*dot(as_float3(relVel) + d_ferrari*ferraricor, as_float3(relPos))*f;
						}
						else
							DrDt = relPos.w*vel_dot_pos*f;
						/* The second formulation takes into consideration the density ratio */
						if (sph_formulation == SPH_F2)
							DrDt *= vel.w/relVel.w;
						force.w += DrDt;

						// pressure part of acceleration (to be multiplied by neib_mass*f)
						switch (sph_formulation) {
							case SPH_F1:
								DvDt = -(p_precalc + P(relVel.w, PART_FLUID_NUM(neib_info))/(relVel.w*relVel.w)); /*I think these are i not index*/
								# ifdef VISC_KEPS
								DvDt -= 2*neib_keps_k/relVel.w/3.f;
								# endif
								break;
							case SPH_F2:
								DvDt = -(p_precalc + P(relVel.w, PART_FLUID_NUM(neib_info)))/(vel.w*relVel.w);
								break;
						}

						/* Viscous forces */
						# if defined(VISC_DYNAMIC) || defined(VISC_KINEMATIC) || defined(VISC_SPS) || defined(VISC_KEPS)
						# if defined(VISC_DYNAMIC)
						const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, d_visccoeff*vel.w,
										d_visccoeff*relVel.w);
						# elif defined(VISC_KINEMATIC)
						const float visc = laminarvisc_kinematic(vel.w, relVel.w, relPos.w, f);
						# elif defined(VISC_SPS)
						const float visc = laminarvisc_kinematic(vel.w, relVel.w, relPos.w, f);
						force.x += relPos.w*f*((tau.xx + neib_tau.xx)*relPos.x + (tau.xy + neib_tau.xy)*relPos.y +
										(tau.xz + neib_tau.xz)*relPos.z);
						force.y += relPos.w*f*((tau.xy + neib_tau.xy)*relPos.x + (tau.yy + neib_tau.yy)*relPos.y +
										(tau.yz + neib_tau.yz)*relPos.z);
						force.z += relPos.w*f*((tau.xz + neib_tau.xz)*relPos.x + (tau.yz + neib_tau.yz)*relPos.y +
										(tau.zz + neib_tau.zz)*relPos.z);
						# elif defined(VISC_KEPS)
						const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, (d_visccoeff+turbVisc)*vel.w,
										(d_visccoeff+neib_tvisc)*relVel.w);
						# endif // VISC_DYNAMIC + elif*

						if(!BOUNDARY(neib_info)) {
							as_float3(force) += visc*as_float3(relVel);
						}

						# elif defined(VISC_ARTVISC)
						if (vel_dot_pos < 0.0f)
							DvDt += artvisc(vel_dot_pos, vel.w, relVel.w, sspeed,
										soundSpeed(relVel.w, PART_FLUID_NUM(neib_info)), r, slength);
						# else
						# error Unknown viscosity!
						# endif // VISC_*

						# ifdef XSPH_KERNEL
						mean_vel -= relPos.w*W<kerneltype>(r, slength)*as_float3(relVel)/(vel.w + relVel.w);
						# endif

						if(boundarytype == SA_BOUNDARY) {
							if(BOUNDARY(neib_info)) {
								// normal vector
								const float3 normal_s = as_float3(belem);

								// pressure boundary term
								bound_term_pres = DvDt*relVel.w*gamAS.x*normal_s;

								// r_as - distance between fluid particle and boundary element along the normal
								float r_as = dot(as_float3(relPos), normal_s);
								if (r_as < deltap)
									r_as = deltap;

								// velocity of fluid particle along the wall
								const float3 vel_tau = as_float3(relVel) - dot(as_float3(relVel), normal_s)*normal_s;

								// These two expressions are correct only when used together with DYNAMICVISC or KEPSVISC model
								# ifdef VISC_KEPS
								// a component of fluid paricle velocity tangential to the wall
								const float3 u_t = as_float3(vel) - dot(as_float3(vel), normal_s)*normal_s;
								const float abs_u_t = length(u_t);
								float y_plus = deltap;

								// we solve iteratively the wall law equation to obtain y+ value
								float u_star = exp(-2.132f)*d_visccoeff/r_as;
								for (int i=0; i<10; i++) {
									y_plus = max(r_as*u_star/d_visccoeff, 11.f);
									u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
								}
								y_plus = max(r_as*u_star/d_visccoeff, 11.f);

								const float denom_term = pow(log(y_plus)/0.41f + 5.2f, 2);
								bound_term_visc = 2*vel.w*abs_u_t*gamAS.x*u_t/denom_term;

								// velocity gradient
								const float3 rhoGGam = gamAS.x*normal_s*relVel.w;

								dvx += relVel.x*rhoGGam;	// dvx = ∑ρs vxas ∇ɣas
								dvy += relVel.y*rhoGGam;	// dvy = ∑ρs vyas ∇ɣas
								dvz += relVel.z*rhoGGam;	// dvz = ∑ρs vzas ∇ɣas
								# else
								bound_term_visc = gamAS.x*d_visccoeff*(vel.w + relVel.w)/r_as*vel_tau;
								# endif

								# ifdef VISC_KEPS
								//to be divided later by rho_a and gamma_a
								diff_term_e += pow(0.09f, 0.75f)/0.41f * (dedt_precalc*pow(keps_k,1.5f)/(r_as*r_as) +
											relVel.w*(d_visccoeff + neib_tvisc/1.3f)*pow(neib_keps_k,1.5f)/(deltap*deltap)) * gamAS.x;
								# endif

							}
							# ifdef VISC_KEPS
							else {
								//to be divided later by rho_a and gamma_a
								diff_term_k += relPos.w*(dkdt_precalc + relVel.w*(d_visccoeff + neib_tvisc))*(keps_k - neib_keps_k)*f/relVel.w;
								diff_term_e += relPos.w*(dedt_precalc + relVel.w*(d_visccoeff + neib_tvisc/1.3f))*(keps_e - neib_keps_e)*f/relVel.w;

								//velocity gradient
								dvx -= relVel.x*as_float3(relPos)*f;	// dvx = -∑mb vxab (ra - rb)/r ∂Wab/∂r
								dvy -= relVel.y*as_float3(relPos)*f;	// dvy = -∑mb vyab (ra - rb)/r ∂Wab/∂r
								dvz -= relVel.z*as_float3(relPos)*f;	// dvz = -∑mb vzab (ra - rb)/r ∂Wab/∂r
							}
							# endif
						} // endif (boundarytype)

						DvDt *= relPos.w*f;
					} else {
						switch (boundarytype) {
							case LJ_BOUNDARY:
								DvDt = LJForce(r);
								break;
							case MK_BOUNDARY:
								DvDt = MKForce(r, slength, pos.w, pos.w);
								break;
							case SA_BOUNDARY:
								// TODO FIXME this is currently encountered when the fluid interacts with a floating object
								DvDt = LJForce(r);
								break;
							default:
								DvDt = 1.0f/0.0f;
								break;
						}
					}
					// interaction between two particles
					if(BOUNDARY(neib_info) && boundarytype == SA_BOUNDARY) {
						as_float3(force) -= bound_term_pres + bound_term_visc/vel.w;
					}
					else {
						as_float3(force) += DvDt*as_float3(relPos);
					}

				} // r < influenceradius
			} // end of loop over neighbors

			# ifdef VISC_DYNAMIC
			const float dynvisc = d_visccoeff*vel.w;
			# elif defined(VISC_KINEMATIC) || defined(VISC_SPS)
			const float dynvisc = d_visccoeff*vel.w/4.0f;				// FXME: check????????
			# elif defined(VISC_ARTVISC)
			const float dynvisc = 0.0f;
			# elif defined(VISC_KEPS)
			const float dynvisc = 0.0f;

			// velocity gradients
			dvx /= vel.w * gGam.w;	// dvx = -1/ɣa*ρa ∑mb vxab (ra - rb)/r ∂Wab/∂r
			dvy /= vel.w * gGam.w;	// dvy = -1/ɣa*ρa ∑mb vyab (ra - rb)/r ∂Wab/∂r
			dvz /= vel.w * gGam.w;	// dvz = -1/ɣa*ρa ∑mb vzab (ra - rb)/r ∂Wab/∂r
			// Calculate norm of the mean strain rate tensor
			float SijSij_bytwo = 2.0f*(dvx.x*dvx.x + dvy.y*dvy.y + dvz.z*dvz.z);	// 2*SijSij = 2.0((∂vx/∂x)^2 + (∂vy/∂yx)^2 + (∂vz/∂z)^2)
			float temp = dvx.y + dvy.x;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vx/∂y + ∂vy/∂x)^2
			temp = dvx.z + dvz.x;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vx/∂z + ∂vz/∂x)^2
			temp = dvy.z + dvz.y;
			SijSij_bytwo += temp*temp;		// 2*SijSij += (∂vy/∂z + ∂vz/∂y)^2
			float S = sqrtf(SijSij_bytwo);
			const float Pturb = turbVisc*S*S;					// production of turbulent kinetic energy (TKE)

			float dkdt = Pturb - keps_e + diff_term_k/vel.w/gGam.w;								// dk/dt
			float dedt = keps_e/keps_k*(1.44f*Pturb - 1.92f*keps_e) + diff_term_e/vel.w/gGam.w;	// de/dt

			keps_dkde[index].x = dkdt;
			keps_dkde[index].y = dedt;
			# else
			# error Unknown viscosity!
			# endif

			// Dividing by gamma
			if (boundarytype == SA_BOUNDARY){
				gGam.w = fmin(fmax(gGam.w, epsilon),1.0f);
				force /= gGam.w;
			}
			// Adding gravity
			as_float3(force) += d_gravity;

			// TODO: check for time step limitation in case of geometrical boundaries (DEM or planes)
			// for viscous fluids
			float geom_coeff = 0.0f;

			// Adding repulsive force computed from DEM
			if (usedem) {
				switch (boundarytype) {
					case LJ_BOUNDARY:
						geom_coeff = DemLJForce(demTex, as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize,
										pos.w, as_float3(vel), dynvisc, force);
						break;
					default:
						break;
				}
			}

			// Adding repulsive force computed from geometric boundaries
			if (d_numplanes) {
				geom_coeff = max(geom_coeff, GeometryForce(d_worldOrigin + as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize,
							pos.w, as_float3(vel), dynvisc, force));
			}

			# ifdef DT_KERNEL
			// storing data for cfl condition in shared memory
			sm_max[threadIdx.x] = max(length(as_float3(force)), sspeed*sspeed/slength);
			# ifdef VISC_KEPS
			sm_max_nut[threadIdx.x] = turbVisc;
			# endif
			# endif

			# ifdef XSPH_KERNEL
			xsph[index] = make_float4(2.0f*mean_vel, 0.0f);
			# endif

			forces[index] = force;
			if (boundarytype == SA_BOUNDARY)
				newGGam[index] = gGam;
		}	// if (FLUID(info))

		else if (boundarytype == SA_BOUNDARY && VERTEX(info)) {

			// oldGGam is used for for the computation of solid angles for gamma. We actually require the inverse vector and we normalize it as all we need are angles
			float4 oldGGam = make_float4(NAN, NAN, NAN, 1.0f);
			bool computeGamma = false;
			if (boundarytype == SA_BOUNDARY) {
				oldGGam = tex1Dfetch(gamTex, index);
				// check whether we need to recompute gamma for vertices, this is only the case if we have moving boundaries ore if gamma is not yet set
				computeGamma = (oldGGam.w < epsilon) || movingBoundaries;
				// if not, then save the old values into the new array
				if (!computeGamma)
					gGam = oldGGam;
				// otherwise prepare oldGGam for the gamma computation
				else
					oldGGam /= -length3(oldGGam);
			}

			if (computeGamma || VISC_TYPE == KEPSVISC) {

				// loop over all neighbors
				for (idx_t i = 0; i < d_neiblist_end; i += d_neiblist_stride) {
					neibdata neib_data = neibsList[i + index];

					if (neib_data == 0xffff) break;

					const uint neib_index = getNeibIndex(pos, pos_corr, cellStart, neib_data, gridPos,
								neib_cellnum, neib_cell_base_index);

					// Compute relative position vector and distance
					// Now relPos is a float4 and neib mass is stored in relPos.w
					#if( __COMPUTE__ >= 20)
					const float4 relPos = pos_corr - posArray[neib_index];
					#else
					const float4 relPos = pos_corr - tex1Dfetch(posTex, neib_index);
					#endif
					const float r = length(as_float3(relPos));

					const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);

					# ifdef VISC_KEPS
					const float4 relVel = as_float3(vel) - tex1Dfetch(velTex, neib_index);
					const float neib_keps_k = tex1Dfetch(keps_kTex, neib_index);
					const float neib_keps_e = tex1Dfetch(keps_eTex, neib_index);
					float neib_tvisc;
					if(FLUID(neib_info))
						neib_tvisc = 0.09f*neib_keps_k*neib_keps_k/neib_keps_e;
					else
						neib_tvisc = 0.0f;
					#endif

					if (r < influenceradius || (boundarytype == SA_BOUNDARY && BOUNDARY(neib_info))) {
						if (BOUNDARY(neib_info)) {
							const float4 belem = tex1Dfetch(boundTex, neib_index);
							const float3 normal_s = as_float3(belem);	// normal vector
							# ifdef VISC_KEPS
							// r_es - distance between vertex particle and boundary element along the normal
							float r_es = dot(as_float3(relPos), normal_s);
							if (r_es < deltap)
								r_es = deltap;
							#endif

							const float2 gamES = Gamma<kerneltype>(slength, relPos, vertPos0[neib_index], vertPos1[neib_index], vertPos2[neib_index], belem, oldGGam, epsilon, computeGamma);
							if (computeGamma){
								gGam.x += gamES.x*belem.x;
								gGam.y += gamES.x*belem.y;
								gGam.z += gamES.x*belem.z;
								gGam.w -= gamES.y;
							}

							# ifdef VISC_KEPS
							// velocity of vertex particle along the wall
							const float3 u_t = as_float3(vel) - dot(as_float3(vel), normal_s)*normal_s;
							const float abs_u_t = length(u_t);
							float y_plus = deltap;

							// we solve iteratively the wall law equation to obtain y+ value
							float u_star = exp(-2.132f)*d_visccoeff/r_es;
							for (int i=0; i<10; i++) {
								y_plus = max(r_es*u_star/d_visccoeff, 11.f);
								u_star = (0.41f*abs_u_t + u_star)/(log(y_plus) + 2.132f + 1);
							}
							y_plus = max(r_es*u_star/d_visccoeff, 11.f);

							const float denom_term = pow(log(y_plus)/0.41f + 5.2f, 2);

							force.x -= 2*abs_u_t*gamES.x*u_t.x/denom_term;
							force.y -= 2*abs_u_t*gamES.x*u_t.y/denom_term;
							force.z -= 2*abs_u_t*gamES.x*u_t.z/denom_term;
							#endif
						}
						# ifdef VISC_KEPS
						else {
							const float vel_dot_pos = dot(as_float3(relVel), as_float3(relPos));	// x.u
							const float f = F<kerneltype>(r, slength);		// 1/r dW/dr
							const float visc = laminarvisc_dynamic(vel.w, relVel.w, relPos.w, f, (d_visccoeff+turbVisc)*vel.w,
											(d_visccoeff+neib_tvisc)*relVel.w);

							force.x += visc*relVel.x;
							force.y += visc*relVel.y;
							force.z += visc*relVel.z;
						} //end if BOUNDARY(neib_info)
						#endif
					} // r < influenceradius
				} // end of loop over neighbors

				gGam.w = fmin(fmax(gGam.w, epsilon),1.0f);
				force /= gGam.w;

			} // end if (computeGamma || VISC_TYPE == KEPSVISC)

			forces[index] = force;
			if (boundarytype == SA_BOUNDARY)
				newGGam[index] = gGam;
		}

		else if (OBJECT(info)) {

			// loop over all neighbors
			for (idx_t i = 0; i < d_neiblist_end; i += d_neiblist_stride) {
				neibdata neib_data = neibsList[i + index];

				if (neib_data == 0xffff) break;

				const uint neib_index = getNeibIndex(pos, pos_corr, cellStart, neib_data, gridPos,
							neib_cellnum, neib_cell_base_index);

				// Compute relative position vector and distance
				// Now relPos is a float4 and neib mass is stored in relPos.w
				#if( __COMPUTE__ >= 20)
				const float4 relPos = pos_corr - posArray[neib_index];
				#else
				const float4 relPos = pos_corr - tex1Dfetch(posTex, neib_index);
				#endif
				const float r = length3(relPos);

				const particleinfo neib_info = tex1Dfetch(infoTex, neib_index);

				if (r < influenceradius) {
					float DvDt = 0.0f;

					// Now object-object and object boundary forces are computed with ODE
					if (FLUID(neib_info) && !OBJECT(neib_info))
						DvDt = relPos.w*LJForce(r);

					as_float3(force) += DvDt*as_float3(relPos);
				}
			}

			uint rbindex = id(info) + d_rbstartindex[object(info)];
			rbforces[rbindex] = force;
			rbtorques[rbindex] = make_float4(cross(d_worldOrigin + as_float3(pos) + gridPos*d_cellSize + 0.5f*d_cellSize
								- d_rbcg[object(info)], as_float3(force)));
		} // else if (OBJECT(info))

	} while (0);

	# ifdef DT_KERNEL
	dtadaptBlockReduce(sm_max, cfl);
	# ifdef VISC_KEPS
	dtadaptBlockReduce(sm_max_nut, cfltvisc);
	# endif
	# endif
}
/************************************************************************************************************/

#undef FORCES_CUDA_KERNEL

/* vi:set ft=cuda: */
